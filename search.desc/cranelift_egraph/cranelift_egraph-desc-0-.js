searchState.loadedDescShard("cranelift_egraph", 0, "ægraph (aegraph, or acyclic e-graph) implementation.\nA trait that allows the aegraph to compute a property of …\nA slice in an arena: like a <code>BumpVec</code>, but has a fixed size …\nA vector of <code>T</code> stored within a <code>BumpArena</code>.\nTrait that allows for equality comparison given some …\nTrait that allows for hashing given some external context.\nA HashMap that takes external context for all operations.\nAn EClass entry. Contains either a single new enode and a …\nAn egraph.\nAn entry in the hashmap.\nAn eclass ID.\nA trait implemented by all “languages” (types that can …\nA new or existing <code>T</code> when adding to a deduplicated set or …\nAn iterator over all nodes in an eclass.\nA reference to a node.\nA union-find data structure. The data structure can …\nAdd a new node.\nAdd an <code>Id</code> to the <code>UnionFind</code>, with its own equivalence class …\nAnalysis and per-node state.\nGet the analysis value for a given eclass. Panics if no …\nAppend two <code>BumpVec</code>s, returning a new one. Consumes both …\nCreate a new arena, pre-allocating space for <code>cap</code> total <code>T</code> …\nReturn the raw bit encoding for this instance.\nReturns a mutable slice view of this <code>BumpVec</code>, given a …\nReturns a mutable slice view of the <code>BumpSlice</code>, given a …\nIf this EClass is just a lone enode, return it.\nIf this EClass is one new enode and a child, return the …\nReturns a slice view of this <code>BumpVec</code>, given a borrow of the\nReturns a slice view of the <code>BumpSlice</code>, given a borrow of …\nReturn the underlying index value as a <code>u32</code>.\nIf this EClass is the union variety, return the two child …\nGet the canonical ID for an eclass. This may be an older …\nGet the canonical ID for an eclass. This may be an older …\nReturns the capacity of this vector. Does not require …\nGet the first child, if any.\nGet the second child, if any.\nEclass definitions. Each eclass consists of an enode, and …\nClone, if <code>T</code> is cloneable.\nDetermine whether <code>a</code> and <code>b</code> are equal, given the context in …\nCompute the hash of <code>value</code>, given the context in <code>self</code> and …\nGet the enodes for a given eclass.\nReturn an Entry cursor on a given bucket for a key, …\nDetermine if two <code>Id</code>s are equivalent, after canonicalizing. …\nFind the canonical <code>Id</code> of a given <code>Id</code>.\nFind the canonical <code>Id</code> of a given <code>Id</code>, updating the data …\nConsume the BumpVec and return its indices to a free pool …\nFreeze the capacity of this BumpVec, turning it into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new <code>BumpVec</code> with the sequence from an iterator.\nCreate a new instance from a <code>u32</code>.\nLook up a key, returning a borrow of the value if present.\nGet the underlying value.\nGet the node, if any, from a node-only or node-and-child …\nHash an <code>Id</code> after canonicalizing it. Update union-find data …\nInsert a new key-value pair, returning the old value …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the length of this vector. Does not require access …\nReturns the length of the <code>BumpSlice</code>.\nCreate an empty hashmap.\nCreate a new aegraph.\nCreate a new arena into which one can allocate <code>BumpVec</code>s.\nCreate a new <code>UnionFind</code>.\nGet the node for this NodeKey, given the <code>nodes</code> from the …\nNode-allocation arena.\nPush an item, growing the capacity if needed.\nReserve <code>extra_len</code> capacity at the end of the vector, …\nCreate a new <code>BumpVec</code> with a single element. The capacity is\nReturns the size of the backing <code>Vec</code>.\nConditionally-compiled trace-log macro. (Borrowed from …\nTruncate the length to a smaller-or-equal length.\nMerge one eclass into another, maintaining the acyclic …\nMerge the equivalence classes of the two <code>Id</code>s.\nUnion-find for canonical ID generation. This lets us name …\nCreate a new <code>BumpVec</code> with the given pre-allocated capacity …\nCreate an empty hashmap with pre-allocated space for the …\nCreate a new aegraph with the given capacity.\nCreate a new <code>UnionFind</code> with the given capacity.")