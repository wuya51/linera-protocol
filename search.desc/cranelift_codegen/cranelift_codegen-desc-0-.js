searchState.loadedDescShard("cranelift_codegen", 0, "Cranelift code generation library.\nThe code size for the function is too large.\nA compilation error.\nA convenient alias for a <code>Result</code> that uses <code>CodegenError</code> as …\nCompilation error, with the accompanying function to help …\n<code>CompiledCode</code> in its final form (i.e. after …\nPersistent data structures and compilation pipeline.\nContains the error value\nAn implementation limit was exceeded.\nA call site record resulting from a compilation.\nA relocation resulting from a compilation.\nA source-location mapping resulting from a compilation.\nRecord of stack map metadata: stack offsets containing …\nA trap record resulting from a compilation.\nContains the success value\nRegister allocator internal error discovered by the …\nA failure to map Cranelift register representation to a …\nAn object that can be used to create the text section of …\nSomething is not supported by the code generator. This …\nVersion number of this crate. \nResulting map of Value labels and their ranges/locations.\nValue location range.\nA list of IR verifier errors.\nThe addend to add to the symbol value.\nMinimum alignment for the function, derived from the use …\nAppends <code>data</code> to the text section with the <code>align</code> specified.\nBasic-block layout info: block edges. Each edge is …\nBasic-block layout info: block start offsets.\nBinary machine code emission.\nMachine code.\nPerform NaN canonicalizing rewrites on the function.\nThe control flow graph of <code>func</code>.\nThe <code>CFGPrinter</code> utility.\nClear all data structures in this context.\nThe trap code.\nCompile the function.\nCompile the function, and emit machine code into a <code>Vec&lt;u8&gt;</code>.\nInternally compiles the function into a stencil.\nReturns the compilation result for this function, …\nCompute the control flow graph.\nCompute dominator tree.\nCompute the loop analysis.\nCreates unwind information for the function.\nCreates unwind information for the function.\nCursor library.\nThis module gives users to instantiate values that …\nDebug tracing helpers.\nPerform dead-code elimination on the function.\nDisassembly, if requested.\nA Dominator Tree represented as mappings of Blocks to …\nDominator tree for <code>func</code>.\nDebug info: stackslots to stack pointer offsets.\nPerform unreachable code elimination.\nThe end of the region of code corresponding to a source …\nThe end of the range. It is an offset in the generated …\nCompletes this text section, filling out any final …\nA control flow graph represented as mappings of basic …\nCompute the control flow graph and dominator tree.\nAllocate a new compilation context with an existing …\nA debug-only option which is used to for\nSize of stack frame, in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe function we’re compiling.\nFunction we tried to compile, for display purposes.\nIf available, return information about the code layout in …\nIf available, return information about the code layout in …\nUnderlying <code>CodegenError</code> that triggered the error.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of Cranelift IR functions.\nInstruction Set Architectures.\nThe kind of relocation.\nRun the legalizer for <code>isa</code> on the function.\nPerform LICM on the function.\nThe source location.\nThe ValueLoc containing a ValueLabel during this range.\nA loop analysis represented as mappings of loops to their …\nLoop analysis of <code>func</code>.\nThe external symbol / name to which this relocation refers.\nAllocate a new compilation context.\nThe offset at which the relocation applies, <em>relative to the</em>\nThe offset at which the trap instruction occurs, <em>relative </em>…\nThe code offset at which this stack map applies.\nThe code offset just past the “end” of the …\nThe call’s opcode.\nOptimize the function, performing all compilation steps up …\nCompact representation of <code>Option&lt;T&gt;</code> for types with a …\nPerform pre-legalization rewrites on the function.\nUtility routines for pretty-printing error messages.\nPerform constant-phi removal on the function.\nReplace all redundant loads with the known values in …\nAttempts to resolve a relocation for this function.\nThe offset of the call’s return address, <em>relative to the </em>…\nSet the flag to request a disassembly when compiling with a\nShared settings module.\nPerform simple GVN on the function.\nDebug info: stackslots to stack pointer offsets.\nThe stack map itself.\nThe start of the region of code corresponding to a source …\nThe start of the range. It is an offset in the generated …\nPass timing.\nEven when trace logging is disabled, the trace macro has a …\nDebug info: value labels to registers/stackslots at code …\nA verifier for ensuring that functions are well formed. It …\nRun the verifier on the function.\nRun the verifier only if the <code>enable_verifier</code> setting is …\nFlag: do we want a disassembly with the CompiledCode?\nConverting Cranelift IR to text.\nAArch64 TLS GD Set the add immediate field to the low 12 …\nAArch64 TLS GD Set an ADRP immediate field to the top 21 …\nabsolute 4-byte\nabsolute 8-byte\nAddend to add to the symbol value.\nArm32 call target\nArm64 call target. Encoded as bottom 26 bits of …\nContainer for information about a vector of compiled code …\nOffset in bytes from the beginning of the function.\nElf x86_64 32 bit signed PC relative offset to two GOT …\nMach-O x86_64 32 bit signed PC relative offset to a …\nRelocation kinds for every ISA\nprocedure call. call symbol expands to the following …\ns390x PC-relative 4-byte offset\ns390x PC-relative 4-byte offset to PLT\ns390x TLS GD64 - 64-bit offset of tls_index for GD symbol …\ns390x TLS GDCall - marker to enable optimization of TLS …\nStack maps record which words in a stack frame contain …\nx86 call to PC-relative 4-byte\nx86 call to PLT-relative 4-byte\nx86 GOT PC-relative 4-byte\nx86 PC-relative 4-byte\nThe 32-bit offset of the target from the beginning of its …\nReturns the raw bitmap that represents this stack map.\nDisplay trait implementation drops the arch, since its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a vec of Bitsets from a slice of bools.\nReturns a specified bit.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of words represented by this stack map.\nNumber of bytes in total.\nA utility for pretty-printing the CFG of a <code>Function</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new CFGPrinter.\nWrite the CFG for this function to <code>w</code>.\nCursor is pointing after the end of a block. New …\nCursor is pointing at an existing instruction. New …\nCursor is before the beginning of a block. No instructions …\nAll cursor types implement the <code>Cursor</code> which provides …\nThe possible positions of a cursor.\nFunction cursor.\nCursor is not pointing anywhere. No instructions can be …\nRebuild this cursor positioned after <code>inst</code>.\nRebuild this cursor positioned at the bottom of <code>block</code>.\nRebuild this cursor positioned at the first insertion …\nRebuild this cursor positioned at the first instruction in …\nRebuild this cursor positioned at <code>inst</code>.\nRebuild this cursor positioned at the last instruction in …\nRebuild this cursor positioned at <code>pos</code>.\nRebuild this cursor positioned at the top of <code>block</code>.\nGet the block corresponding to the current position.\nGet the instruction corresponding to the current position, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe referenced function.\nGo to the position after a specific instruction, which …\nGo to the bottom of <code>block</code> which must be inserted into the …\nGo to the position for inserting instructions at the …\nGo to the first instruction in <code>block</code>.\nGo to a specific instruction which must be inserted in the …\nGo to the last instruction in <code>block</code>.\nGo to the top of <code>block</code> which must be inserted into the …\nCreate an instruction builder that inserts an instruction …\nInsert a block at the current position and switch to it.\nInsert an instruction at the current position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBorrow a reference to the function layout that this cursor …\nBorrow a mutable reference to the function layout that …\nCreate a new <code>FuncCursor</code> pointing nowhere.\nGo to the top of the next block in layout order and return …\nMove to the next instruction in the same block and return …\nGet the current cursor position.\nGo to the bottom of the previous block in layout order and …\nMove to the previous instruction in the same block and …\nRemove the instruction under the cursor.\nRemove the instruction under the cursor.\nSet the current position.\nSet the source location that should be assigned to new …\nGet the source location that should be assigned to new …\nUse the source location of <code>inst</code> for future instructions.\nExchange this cursor for one with a set source location.\nRepresent a data value. Where Value is an SSA reference, …\nRecord failures to cast DataValue.\nHelper structure for printing bracket-enclosed vectors of …\nPerforms a bitwise comparison over the contents of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to cast an immediate integer (a wrapped <code>i64</code> on most …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if the value is a vector (i.e. <code>DataValue::V128</code>…\nRead a DataValue from a slice using a given Type.\nRead a DataValue from a memory location using a given Type.\nReturn the Cranelift IR Type for this DataValue.\nHelper function for displaying <code>Vec&lt;DataValue&gt;</code>.\nWrite a DataValue to a slice.\nWrite a DataValue to a memory location.\nHelper for printing lists.\nPrefix added to the log file names, just before the thread …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator that enumerates the direct children of a block …\nThe dominator tree for a single function.\nOptional pre-order information that can be computed for a …\nGet the CFG post-order of blocks that was used to compute …\nGet an iterator over the direct children of <code>block</code> in the …\nClear the data structures used to represent the dominator …\nCompute the common dominator of two basic blocks.\nReset and compute a CFG post-order and dominator tree.\nRecompute this data structure to match <code>domtree</code>.\nReturns <code>true</code> if <code>a</code> dominates <code>b</code>.\nFast, constant time dominance check with block granularity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> reachable from the entry block?\nCheck if the dominator tree is in a valid state.\nFind the last instruction in <code>a</code> that dominates <code>b</code>. If no …\nAllocate a new blank dominator tree. Use <code>compute</code> to …\nCreate a new blank <code>DominatorTreePreorder</code>.\nCompare two program points according to the dominator tree …\nCompare two blocks according to the dominator pre-order.\nCompare two value defs according to the dominator tree …\nCompare two program points relative to a reverse …\nAllocate and compute a dominator tree.\nA basic block denoted by its enclosing Block and last …\nThe Control Flow Graph maintains a mapping of blocks to …\nAn iterator over block predecessors. The iterator type is …\nAn iterator over block successors. The iterator type is …\nEnclosing Block key.\nClear all data structures in this control flow graph.\nCompute the control flow graph of <code>func</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLast instruction in the basic block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the CFG is in a valid state.\nAllocate a new blank control flow graph.\nConvenient method to construct new BlockPredecessor.\nGet an iterator over the CFG predecessors to <code>block</code>.\nRecompute the control flow graph of <code>block</code>.\nGet an iterator over the CFG successors to <code>block</code>.\nAllocate and compute the control flow graph for <code>func</code>.\nFunction parameter or return value descriptor.\nAdd\nA value alias to original value.\nAnd\nFunction argument extension options.\nThe special purpose of a function argument.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3)\nAtomicCas(imms=(flags: ir::MemFlags), vals=3)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nDescribes the arithmetic operation in an atomic memory …\nFailed float-to-int conversion.\nSignature mismatch on indirect call.\nBig-endian\nBinary(imms=(), vals=2)\nBinary(imms=(), vals=2)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1)\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1)\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1)\nA block header.\nBranch(imms=(destination: ir::Block), vals=1)\nBranch(imms=(destination: ir::Block), vals=1)\nBranchTable(imms=(destination: ir::Block, table: …\nBranchTable(imms=(destination: ir::Block, table: …\nCall(imms=(func_ref: ir::FuncRef), vals=0)\nCall(imms=(func_ref: ir::FuncRef), vals=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1)\nceil.f32\nceil.f64\nTLS index symbol for the current thread. Used in COFF/PE …\nCondTrap(imms=(code: ir::TrapCode), vals=1)\nCondTrap(imms=(code: ir::TrapCode), vals=1)\nValue is a multiple of how many instances of <code>vector_type</code> …\nA dynamic heap can be relocated to a different base …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nELF well-known linker symbol <em>GLOBAL_OFFSET_TABLE</em>\nElf __tls_get_addr\nElf __tls_get_offset\nEndianness of a memory access.\nAn expanded program point directly exposes the variants, …\nAn external function.\nThe name of an external is either a reference to a …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2)\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2)\nfloor.f32\nfloor.f64\nfma.f32\nfma.f64\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0)\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0)\nInformation about a global value declaration.\nHeapAddr(imms=(heap: ir::Heap, offset: …\nHeapAddr(imms=(heap: ir::Heap, offset: …\nInformation about a heap declaration.\nHeapLoad(imms=(heap_imm: ir::HeapImm), vals=1)\nHeapLoad(imms=(heap_imm: ir::HeapImm), vals=1)\nA wasm atomic operation was presented with a …\nA <code>heap_addr</code> instruction detected an out-of-bounds error.\nHeapStore(imms=(heap_imm: ir::HeapImm), vals=2)\nHeapStore(imms=(heap_imm: ir::HeapImm), vals=2)\nStyle of heap including style-specific information.\nValue is an offset from another global value.\nIndirect call to a null table entry.\nBuilder that inserts an instruction at the current …\nAn instruction in the function.\nConvenience methods for building instructions.\nBase trait for instruction builders.\nBase trait for instruction inserters.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2)\nIntAddTrap(imms=(code: ir::TrapCode), vals=2)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2)\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nAn integer division by zero.\nAn integer arithmetic operation caused an overflow.\nExecution has potentially run too long and may be …\nJump(imms=(destination: ir::Block), vals=0)\nJump(imms=(destination: ir::Block), vals=0)\nMap of jump tables.\nA well-known symbol.\nA well-known symbol.\nThe particular location for a value.\nThe name of a runtime library routine.\nA well-known runtime library function.\nLittle-endian\nLoad(imms=(flags: ir::MemFlags, offset: …\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1)\nFlags for memory operations like load/store.\nlibc.memcmp\nlibc.memcpy\nlibc.memmove\nlibc.memset\nMultiAry(imms=(), vals=0)\nMultiAry(imms=(), vals=0)\nNand\nnearest.f32\nnearest.f64\nNo extension, high bits are indeterminate.\nA normal user program value passed to or from a function.\nNullAry(imms=(), vals=0)\nNullAry(imms=(), vals=0)\nOr\nprobe for stack overflow. These are emitted for functions …\nContext for ordering program points.\nA <code>ProgramPoint</code> represents a position in a function where …\nNew-backend Reg.\nSource location relative to another base source location.\nInstruction builder that replaces an existing instruction.\nNew-backend offset from stack pointer.\nSigned extension: high bits in register replicate sign bit.\nShuffle(imms=(imm: ir::Immediate), vals=2)\nShuffle(imms=(imm: ir::Immediate), vals=2)\nFunction signature.\nA signature identifier.\nSigned max\nSigned min\nA source location.\nA stack limit pointer.\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nThe current stack space was exhausted.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nOriginal value labels assigned at transform.\nA static heap has a fixed base address and a number of …\nStore(imms=(flags: ir::MemFlags, offset: …\nStore(imms=(flags: ir::MemFlags, offset: …\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2)\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2)\nA C struct passed as argument.\nStruct return pointer.\nSub\nValue is symbolic, meaning it’s a name which will be …\nTableAddr(imms=(table: ir::Table, offset: …\nTableAddr(imms=(table: ir::Table, offset: …\nInformation about a table declaration.\nA <code>table_addr</code> instruction detected an out-of-bounds error.\nTernary(imms=(), vals=3)\nTernary(imms=(), vals=3)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2)\nA test case function name of up to a hardcoded amount of …\nA name for a test case, mostly intended for Cranelift …\nTrap(imms=(code: ir::TrapCode), vals=0)\nTrap(imms=(code: ir::TrapCode), vals=0)\nA trap code describing the reason for a trap.\ntrunc.f32\nfrunc.f64\nUnsigned extension: high bits in register are 0.\nUnsigned max\nUnsigned min\nUnary(imms=(), vals=1)\nUnary(imms=(), vals=1)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0)\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0)\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0)\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0)\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0)\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0)\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0)\nCode that was supposed to have been unreachable was …\nA user-defined name, with semantics left to the user.\nA reference to a name in a user-defined symbol table.\nA user-defined trap code.\nAn external name in a user-defined symbol table.\nAn explicit name for a user-defined function, be it …\nA VM context pointer.\nValue is the address of the VM context struct.\nMarked with a label value.\nValue label assignements: label starts or value aliases.\nA label of a Value.\nExchange\nXor\nTest if the <code>aligned</code> flag is set.\nGet a list of all known <code>LibCall</code>’s.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically store <code>x</code> to memory at <code>p</code>.\nAtomically store <code>x</code> to memory at <code>p</code>.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and.\nBitwise and with immediate.\nBitwise and with immediate.\nBitwise and not.\nBitwise and not.\nThe address of the start of the heap’s storage.\nGlobal value giving the address of the start of the table.\nReinterpret the bits in <code>x</code> as a different type.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nReverse the bits of a integer.\nRead the bits of this source location.\nConditional select of bits.\nConditional select of bits.\nConvert <code>x</code> to an integer mask.\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise not.\nBitwise or.\nBitwise or.\nBitwise or with immediate.\nBitwise or with immediate.\nBitwise or not.\nBitwise or not.\nGlobal value giving the current bound of the table, in …\nIndirect branch via jump table.\nIndirect branch via jump table.\nBranch when non-zero.\nBranch when non-zero.\nBranch when zero.\nBranch when zero.\nReverse the byte order of an integer.\nReverse the byte order of an integer.\nInsert an instruction and return a reference to it, …\nBitwise xor.\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor with immediate.\nBitwise xor not.\nBitwise xor not.\nDirect function call.\nDirect function call.\nCalling convention.\nIndirect function call.\nIndirect function call.\nRound floating point round to integral, towards positive …\nRound floating point round to integral, towards positive …\nClear the signature so it is identical to a fresh one …\nCount leading sign bits.\nCount leading sign bits.\nCount leading zero bits.\nCount leading zero bits.\nCompare the program points <code>a</code> and <code>b</code> relative to this …\nWill this function be defined nearby, such that it will …\nCondition codes for the Cranelift code generator.\nConstants\nCount trailing zeros.\nCount trailing zeros.\nGet an immutable reference to the data flow graph that …\nGet an immutable reference to the data flow graph.\nGet a mutable reference to the data flow graph that will …\nGet a mutable reference to the data flow graph.\nEncodes an assembly debug trap.\nEncodes an assembly debug trap.\nData flow graph tracking Instructions, Values, and blocks.\nReturns a displayable version of the <code>ExtFuncData</code>, with or …\nReturns a display for the current <code>ExternalName</code>, with extra …\nGet the address of a dynamic stack slot.\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nStore a value to a dynamic stack slot.\nDynamic IR types\nThe size of a table element, in bytes.\nReturn endianness of the memory access.  This will return …\nCranelift IR entity references.\nExpands the relative source location into an absolute one, …\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nFloating point absolute value.\nFloating point addition.\nFloating point addition.\nFloating point comparison.\nFloating point comparison.\nFloating point copy sign.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConvert unsigned integer to floating point.\nConverts packed signed 32-bit integers to packed double …\nConverts packed signed 32-bit integers to packed double …\nConverts floating point scalars to signed integer.\nConverts floating point scalars to signed integer.\nConvert floating point to signed integer as fcvt_to_sint …\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nA memory fence.  This must provide ordering to ensure …\nFloating point comparison returning flags.\nFloating point comparison returning flags.\nRound floating point round to integral, towards negative …\nRound floating point round to integral, towards negative …\nFloating point fused multiply-and-add.\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point maximum, propagating NaNs using the …\nFloating point pseudo-maximum, propagating NaNs.  This …\nFloating point pseudo-maximum, propagating NaNs.  This …\nFloating point minimum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point pseudo-minimum, propagating NaNs.  This …\nFloating point pseudo-minimum, propagating NaNs.  This …\nFloating point multiplication.\nFloating point multiplication.\nFloating point negation.\nFloating point negation.\nConvert <code>x</code> to a larger floating point format.\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSource location when it is in effect\nCreates a new <code>RelSourceLoc</code> based on the given base and …\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nFloating point subtraction.\nGet the address of a function.\nGet the address of a function.\nIntermediate representation of a function.\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nConverts packed single precision floating point to packed …\nGet the address in the frame pointer register.\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGets the content of the pinned register, when it’s …\nGet a function reference for the probestack function in …\nGet the PC where this function will transfer control to …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nGet the address in the stack pointer register.\nReturn the type of this global.\nCompute the value of global GV.\nCompute the value of global GV.\nTest if the <code>heap</code> bit is set.\nBounds check and compute absolute address of <code>index + Offset</code>…\nBounds check and compute absolute address of <code>index + Offset</code>…\nLoad a value from the given heap at address <code>index + offset</code>,\nLoad a value from the given heap at address <code>index + offset</code>,\nStore <code>a</code> into the given heap at address <code>index + offset</code>, …\nStore <code>a</code> into the given heap at address <code>index + offset</code>, …\nInteger absolute value with wrapping: <code>a := |x|</code>.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd integers with carry in and out.\nAdd integers with carry in and out.\nAdd integers with carry in.\nAdd integers with carry in.\nAdd integers with carry out.\nAdd integers with carry out.\nAdd integers with carry in and out.\nAdd integers with carry in and out.\nAdd integers with carry in.\nAdd integers with carry in.\nAdd integers with carry out.\nAdd integers with carry out.\nAdd immediate integer.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nInteger comparison.\nCompare scalar integer to a constant.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nInteger constant.\nCompare scalar integers and return flags.\nCompare scalar integers and return flags.\nCompare scalar integer to a constant and return flags.\nCompare scalar integer to a constant and return flags.\nImmediate operands for Cranelift instructions\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nInteger multiplication by immediate constant.\nArbitrary.\nThe index type for the heap.\nThe index type for the table.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInsert a new instruction which belongs to the DFG.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInstruction formats and opcodes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nImmediate reverse wrapping subtraction: …\nIs the range from <code>inst</code> to <code>block</code> just the gap between …\nIs this the default source location?\nIs this the default relative source location?\nReference verification.\nReference verification.\nDoes this return more than one normal value? (Pre-struct …\nReference verification.\nReference verification.\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nSubtract integers with borrow in.\nSubtract integers with borrow in.\nSubtract integers with borrow in and out.\nSubtract integers with borrow in and out.\nSubtract integers with borrow out.\nSubtract integers with borrow out.\nSubtract integers with borrow in.\nSubtract integers with borrow in.\nSubtract integers with borrow in and out.\nSubtract integers with borrow in and out.\nSubtract integers with borrow out.\nSubtract integers with borrow out.\nJump.\nJump.\nJump table representation.\nThe label index.\nFunction layout.\nLoad from memory at <code>p + Offset</code>.\nLoad from memory at <code>p + Offset</code>.\nIf this global references a symbol, return an estimate of …\nGuaranteed minimum heap size in bytes. Heap accesses …\nGuaranteed minimum table size in elements. Table accesses …\nName of the external function.\nArbitrary.\nRound floating point round to integral, towards nearest …\nRound floating point round to integral, towards nearest …\nCreate a new builder which inserts instructions at <code>pos</code>. …\nCreate a <code>ReplaceBuilder</code> that will overwrite <code>inst</code>.\nCreate a new blank signature.\nCreate a parameter with default flags.\nCreates a new UserExternalName.\nCreate a new empty set of flags.\nCreate a new source location with the given bits.\nCreate a new relative source location with the given bits.\nReturns a slice of all traps except <code>TrapCode::User</code> traps\nJust a dummy instruction.\nJust a dummy instruction.\nTest if the <code>notrap</code> flag is set.\nNull constant value for reference types.\nNull constant value for reference types.\nHow many special parameters does this function have?\nHow many special returns does this function have?\nSize in bytes of the offset-guard pages following the heap.\nThe arguments passed to the function.\nPopulation count\nPopulation count\nSpecial purpose of argument, or <code>Normal</code>.\nTest if the <code>readonly</code> flag is set.\nReturn an estimate of the distance to the referred-to …\nA resumable trap.\nA resumable trap.\nA resumable trap to be called when the passed condition is …\nA resumable trap to be called when the passed condition is …\nReturn from the function.\nReturn from the function.\nValues returned from the function.\nRotate left.\nRotate left.\nRotate left by immediate.\nRotate left by immediate.\nRotate right.\nRotate right.\nRotate right by immediate.\nRotate right by immediate.\nAdd with signed saturation.\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nCopies a scalar value to a vector value.  The scalar is …\nSigned integer division rounded toward zero: …\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nSigned integer division by an immediate constant.\nConditional select.\nConditional select.\nConditional select intended for Spectre guards.\nConditional select intended for Spectre guards.\nSet the <code>aligned</code> flag.\nSet a flag bit by name.\nSet endianness of the memory access.\nSet the <code>heap</code> bit. See the notes about mutual exclusion with\nSet the <code>notrap</code> flag.\nSets the content of the pinned register, when it’s …\nSets the content of the pinned register, when it’s …\nSet the <code>readonly</code> flag.\nSet the <code>table</code> bit. See the notes about mutual exclusion …\nSet the <code>vmctx</code> bit. See the notes about mutual exclusion …\nConvert <code>self</code> to a parameter type with the <code>sext</code> flag set.\nConvert <code>x</code> to a larger integer type by sign-extending.\nConvert <code>x</code> to a larger integer type by sign-extending.\nSIMD vector shuffle.\nSIMD vector shuffle.\nGet a Signature for the function targeted by this LibCall.\nCall signature of function.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nSigned integer maximum.\nSigned integer maximum.\nSigned integer minimum.\nSigned integer minimum.\nSigned integer multiplication, producing the high half of a\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCreate a special-purpose parameter that is not (yet) bound …\nFind the index of a presumed unique special-purpose …\nFind the index of a presumed unique special-purpose …\nVector splat.\nVector splat.\nFixed-point multiplication of numbers in the QN format, …\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nFloating point square root.\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSigned shift right by immediate.\nSubtract with signed saturation.\nSubtract with signed saturation.\nGet the address of a stack slot.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nLoad a value from a stack slot at the constant offset.\nStore a value to a stack slot at a constant offset.\nStore a value to a stack slot at a constant offset.\nStack slots.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nHeap style, with additional style-specific info.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nVector swizzle.\nVector swizzle.\nAssume that <code>self</code> is an <code>GlobalValueData::Symbol</code> and return …\nCompute the value of global GV, which is a symbolic value.\nCompute the value of global GV, which is a symbolic value.\nTest if the <code>table</code> bit is set.\nBounds check and compute absolute address of a table entry.\nBounds check and compute absolute address of a table entry.\nCreates a new external name from a sequence of bytes. …\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nCompute the value of global GV, which is a TLS (thread …\nTerminate execution unconditionally.\nTerminate execution unconditionally.\nTrap when non-zero.\nTrap when non-zero.\nTrap when zero.\nTrap when zero.\nRound floating point round to integral, towards zero.\nRound floating point round to integral, towards zero.\nCreate a set of flags representing an access from a “…\nCommon types for the Cranelift code generator.\nUnsigned addition of x and y, trapping if the result …\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nUnsigned integer division by an immediate constant.\nConvert <code>self</code> to a parameter with the <code>uext</code> flag set.\nConvert <code>x</code> to a larger integer type by zero-extending.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer maximum.\nUnsigned integer minimum.\nUnsigned integer minimum.\nUnsigned integer multiplication, producing the high half …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nGet the instruction we know is inside.\nUnsigned integer remainder.\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nUnsigned integer remainder with immediate divisor.\nCreate a new external name from a user-defined external …\nCreate a new external name from a user-defined external …\nDoes this signature have a parameter whose <code>ArgumentPurpose</code> …\nDoes this signature have a return whose <code>ArgumentPurpose</code> is …\nDoes this signature take an struct return pointer …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nUnsigned shift right by immediate.\nSubtract with unsigned saturation.\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nType of the argument value.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nVector concatenation.\nVector concatenation.\nSIMD vector constant.\nSIMD vector constant.\nReduce a vector to a scalar integer.\nReduce a vector to a scalar integer.\nTest if the <code>vmctx</code> bit is set.\nVector lane select.\nVector lane select.\nSplit a vector into two halves.\nSplit a vector into two halves.\nTakes corresponding elements in <code>x</code> and <code>y</code>, performs a …\nTakes corresponding elements in <code>x</code> and <code>y</code>, performs a …\nSet the <code>aligned</code> flag, returning new flags.\nSet endianness of the memory access, returning new flags.\nSet the <code>heap</code> bit, returning new flags.\nSet the <code>notrap</code> flag, returning new flags.\nSet the <code>readonly</code> flag, returning new flags.\nReuse a single result value.\nReuse result values in <code>reuse</code>.\nSet the <code>table</code> bit, returning new flags.\nSet the <code>vmctx</code> bit, returning new flags.\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nSpecifies whether the memory that this refers to is …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nHeap bound in bytes. The offset-guard pages are allocated …\nGlobal value providing the current bound of the heap in …\nSource location when it is in effect\nThe label index.\nCommon traits of condition codes.\n<code>==</code>.\nEQ\nCondition code for comparing floating point numbers.\nGT\nGT | EQ\nCondition code for comparing integers.\nLT\nLT | EQ\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nEQ | LT | GT\nLT | GT\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nReturns a slice with all possible IntCC values.\nReturns a slice with all possible FloatCC values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the inverse condition code of <code>self</code>.\nGet the reversed condition code for <code>self</code>.\nGet the corresponding string condition code for the IntCC …\nGet the corresponding IntCC with the signed component …\nGet the corresponding IntCC with the equal component …\nThis type describes the actual constant data. Note that …\nMaintains the mapping between a constant handle (i.e.  …\nAdd new bytes to the constant data.\nReturn the data as a slice.\nReturn the combined size of all of the constant values in …\nEmpty the constant pool of all data.\nIterate over mutable entries in the constant pool in …\nExpand the size of the constant data to <code>expected_size</code> …\nPrint the constant data in hexadecimal format, e.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a hexadecimal string to <code>ConstantData</code>. This is the …\nRetrieve the constant data given a handle.\nInsert constant data into the pool, returning a handle for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the data to a vector.\nCheck if the constant contains any bytes.\nIterate over the constant’s bytes.\nIterate over the constants in insertion order.\nReturn the number of bytes in the constant.\nReturn the number of constants in the pool.\nCreate a new constant pool instance.\nLink a constant handle to its value. This does not …\nA data flow graph defines all instructions and basic …\nObject that can display an instruction.\nValue is the n’th parameter to a block.\nValue is the n’th result of an instruction.\nWhere did a value come from?\nIterator over all Values in a DFG\nInserts a <code>ValueLabelAssignments::Alias</code> for <code>to_alias</code> if …\nCheck if <code>inst</code> is a branch.\nAppend a parameter with type <code>ty</code> to <code>block</code>.\nSimilar to <code>append_block_param</code>, append a parameter with …\nAppend a new value argument to an instruction.\nAppend a new instruction result value to <code>inst</code>.\nAppend an existing value to <code>block</code>’s parameters.\nAttach an existing value to the result value list for <code>inst</code>.\nReturns <code>true</code> if the given block reference is valid.\nGet the types of the parameters on <code>block</code>.\nGet the parameters on <code>block</code>.\nGet the call signature of a direct or indirect call …\nTurn a value into an alias of another.\nCheck that the given concrete <code>Type</code> has been defined in the …\nClear everything.\nClear the list of result values from <code>inst</code>.\nStarts collection of debug information.\nCompute the type of an instruction result from opcode …\nConstants used within the function\nGet the controlling type variable, or <code>INVALID</code> if <code>inst</code> isn…\nDetach all the parameters from <code>block</code> and return them as a …\nDetach the list of result values from <code>inst</code> and return it.\nReturns an object that displays <code>inst</code>.\nReturns an object that displays the given <code>value</code>’s …\nDynamic types created.\nExternal function references. These are functions that can …\nGet the first result of an instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest if <code>inst</code> has any result values currently.\nOut-of-line heap access immediates that don’t fit in …\nStores large immediates that otherwise will not fit on …\nGet the instruction where the value was defined, if any.\nGet all value arguments on <code>inst</code> as a slice.\nGet all value arguments on <code>inst</code> as a mutable slice.\nGet the fixed value arguments on <code>inst</code> as a slice.\nGet the fixed value arguments on <code>inst</code> as a mutable slice.\nReturns <code>true</code> if the given instruction reference is valid.\nReturn all the results of an instruction.\nReturn all the results of an instruction as ValueList.\nGet the variable value arguments on <code>inst</code> as a slice.\nGet the variable value arguments on <code>inst</code> as a mutable …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new basic block.\nDeclares a dynamic vector type\nCreate a new instruction.\nCreate result values for an instruction that produces …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate an invalid value, to pad the index space. This is …\nCreate a new value alias. This is only for use by the …\nCreate a new empty <code>DataFlowGraph</code>.\nGet the number component of this definition.\nGet the number of parameters on <code>block</code>.\nGet the total number of basic blocks created in this …\nGet the total number of instructions created in this …\nGet the total number of values.\nThe pre-legalization signature for each entry in <code>signatures</code>…\nGet the program point where the value was defined.\nRemoves <code>val</code> from <code>block</code>‘s parameters by a standard linear …\nCreate a <code>ReplaceBuilder</code> that will replace <code>inst</code> with a new …\nReplace a block parameter with a new value of type <code>ty</code>.\nReplace an instruction result with a new value of type …\nReplace the results of one instruction with aliases to the …\nResolve value aliases.\nResolve all aliases among inst’s arguments.\nCompute the type of an alias. This is only for use in the …\nFunction signature table. These signatures are referenced …\nRemoves <code>val</code> from <code>block</code>’s parameters by swapping it with …\nUnwrap the block there the parameter is defined, or panic.\nUnwrap the instruction where the value was defined, or …\nIf <code>v</code> is already defined as an alias, return its …\nGet the definition of a value.\nDetermine if <code>v</code> is an attached instruction result / block …\nCheck if a value reference is valid.\nCheck if a value reference is valid, while being aware of …\nMemory pool of value lists.\nGet the type of a value.\nGet an iterator over all values.\nSaves Value labels.\nA dynamic type object which has a base vector type and a …\nAll allocated dynamic types.\nBase vector type, this is the minimum size of the type.\nConvert ‘base_vector_ty’ into a concrete dynamic …\nThe dynamic scaling factor of the base vector type.\nConvert a dynamic-vector type to a fixed-vector type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new dynamic type.\nAn opaque reference to any of the entities defined in this …\nAn opaque reference to a basic block in a <code>Function</code>.\na basic block.\nAn opaque reference to a constant.\nA constant.\nAn opaque reference to a dynamic stack slot.\nA dynamic stack slot.\nAn opaque reference to a dynamic type.\nA dynamic type\nAn opaque reference to another <code>Function</code>.\nAn external function.\nThe whole function.\nAn opaque reference to a global value.\nA Global value.\nAn opaque reference to a heap.\nA heap.\nAn opaque reference to some out-of-line immediates for …\nAn opaque reference to an immediate.\nAn opaque reference to an instruction in a <code>Function</code>.\nAn instruction.\nAn opaque reference to a jump table.\nA jump table.\nAn opaque reference to a function <code>Signature</code>.\nA function call signature.\nA function’s stack limit\nAn opaque reference to a stack slot.\nA stack slot.\nAn opaque reference to a WebAssembly table.\nA table.\nA reference to an <code>UserExternalName</code>, declared with …\nAn opaque reference to an SSA value.\nAn SSA value.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new block reference from its number. This …\nCreate a value from its number representation. This is the …\nCreate a new stack slot reference from its number.\nCreate a new stack slot reference from its number.\nCreate a new dynamic type reference from its number.\nCreate a new global value reference from its number.\nCreate a const reference from its number.\nCreate an immediate reference from its number.\nCreate a new jump table reference from its number.\nCreate a new external function reference from its number.\nCreate a new function signature reference from its number.\nCreate a new heap reference from its number.\nCreate a new <code>HeapImm</code> reference from its number.\nCreate a new table reference from its number.\nWrapper type capable of displaying a <code>Function</code> with correct …\nAdditional annotations for function display.\nFunctions can be cloned, but it is not a very fast …\nFunction parameters used when creating this function, and …\nFunction fields needed when compiling a function.\nA version marker used to ensure that serialized clif ir is …\nReturns the base <code>SourceLoc</code>.\nChanges the destination of a jump or branch instruction. …\nClear all data structures in this function.\nStarts collection of debug information.\nCreates a dynamic stack slot in the function, to be used …\nDeclares a global value accessible to the function.\nDeclares a heap accessible to the function.\nCreates a jump table in the function, to be used by …\nCreates a sized stack slot in the function, to be used by …\nDeclares a table accessible to the function.\nDeclare a user-defined external function import, to be …\nData flow graph containing the primary definition of all …\nReturn an object that can display this function with …\nReturn an object that can display this function with …\nDynamic stack slots allocated in this function.\nSets the base <code>SourceLoc</code>, if not set yet, and returns the …\nRetrieve a <code>UserExternalNameRef</code> for the given name, or add …\nSize occupied by all stack slots associated with this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a concrete <code>Type</code> from a user defined <code>DynamicType</code>.\nFind the global dyn_scale value associated with given …\nFind the global dyn_scale for the given stack slot.\nGlobal values referenced.\nHeaps referenced.\nDeclare an external function import.\nAdds a signature which can later be used to declare an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the specified block can be encoded as a basic …\nReturns true if the function is function that doesn’t …\nJump tables used in this function.\nLayout of blocks and instructions in the function body.\nName of this function.\nCreates a new <code>FunctionParameters</code> with the given name.\nCreate a new empty, anonymous function with a Fast calling …\nAll the parameters that can be applied onto the function …\nResets an already existing user function name to a new …\nRewrite the branch destination to <code>new_dest</code> if the …\nSets an absolute source location for the given instruction.\nSignature of this function.\nSized stack slots allocated in this function.\nFind a presumed unique special-purpose function parameter …\nReturns an absolute source location for the given …\nSource locations.\nAn optional global value which represents an expression …\nAll the fields required for compiling a function, …\nTables referenced.\nReplace the <code>dst</code> instruction’s data with the <code>src</code> …\nReturns the internal mapping of <code>UserExternalNameRef</code> to …\nEnable value labels annotations.\nA version marker used to ensure that serialized clif ir is …\nCreate a function with the given name and signature.\nOut-of-line heap access immediates.\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nConvert a type into a vector of bytes; all implementors in …\n32-bit signed immediate offset.\nA 32-bit unsigned integer immediate operand.\n64-bit immediate unsigned integer operand.\n8-bit unsigned integer immediate operand.\nA 128-bit immediate operand.\nComputes the absolute value of self.\nComputes the absolute value of self.\nConverts Self to a rust f32\nConverts Self to a rust f64\nConvert the immediate into a slice.\nReturns the value of this immediate.\nGet the bitwise representation.\nGet the bitwise representation.\nIterate over the bytes in the constant.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns a number composed of the magnitude of self and the …\nReturns a number composed of the magnitude of self and the …\nCreate an <code>Ieee32</code> number representing the greatest negative …\nCreate an <code>Ieee64</code> number representing the greatest negative …\nThe memory flags for the heap access.\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe heap being accessed.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the little-endian byte representation of the …\nCheck if the value is a NaN.\nCheck if the value is a NaN. For Ieee64, this means …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self is positive or negative zero\nReturns true if self is positive or negative zero\nReturn self negated.\nReturn self negated.\nCreate a new <code>Imm64</code> representing the signed number <code>x</code>.\nCreate a new <code>Uimm64</code> representing the unsigned number <code>x</code>.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code>.\nThe static offset added to the heap access’s index.\nCreate an <code>Ieee32</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee64</code> number representing <code>2.0^n</code>.\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nSign extend this immediate as if it were a signed integer …\nReturns the square root of self.\nReturns the square root of self.\nConvert the immediate into a vector.\nReturns the integer part of <code>self</code>. This means that …\nReturns the integer part of <code>self</code>. This means that …\nAdd in the signed number <code>x</code> if possible.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code> if …\nCreate a new <code>Ieee32</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee64</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee32</code> representing the number <code>x</code>.\nCreate a new <code>Ieee64</code> representing the number <code>x</code>.\nReturn self negated.\nReturn self negated.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3)\n<code>a = atomic_cas MemFlags, p, e, x</code>. (AtomicCas) Type …\n<code>a = atomic_load MemFlags, p</code>. (LoadNoOffset)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\n<code>a = atomic_rmw MemFlags, AtomicRmwOp, p, x</code>. (AtomicRmw)\n<code>atomic_store MemFlags, x, p</code>. (StoreNoOffset) Type inferred …\n<code>a = avg_round x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = band_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nBinary(imms=(), vals=2)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1)\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1)\n<code>a = bitcast MemFlags, x</code>. (LoadNoOffset)\n<code>a = bitrev x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bitselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = bmask x</code>. (Unary)\n<code>a = bnot x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nThe operand is bound to a known type.\n<code>br_table x, block, JT</code>. (BranchTable)\nBranch(imms=(destination: ir::Block), vals=1)\nInformation about branch and jump instructions.\nBranchTable(imms=(destination: ir::Block, table: …\n<code>brnz c, block, args</code>. (Branch) Type inferred from <code>c</code>.\n<code>brz c, block, args</code>. (Branch) Type inferred from <code>c</code>.\n<code>a = bswap x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bxor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bxor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bxor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nCall(imms=(func_ref: ir::FuncRef), vals=0)\n<code>rvals = call FN, args</code>. (Call)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1)\n<code>rvals = call_indirect SIG, callee, args</code>. (CallIndirect) …\nInformation about call instructions.\n<code>a = ceil x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = cls x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = clz x</code>. (Unary) Type inferred from <code>x</code>.\nCondTrap(imms=(code: ir::TrapCode), vals=1)\n<code>a = ctz x</code>. (Unary) Type inferred from <code>x</code>.\n<code>debugtrap</code>. (NullAry)\nThis is a direct call to an external function declared in …\n<code>addr = dynamic_stack_addr DSS</code>. (DynamicStackLoad)\nDynamicStackLoad(imms=(dynamic_stack_slot: …\n<code>a = dynamic_stack_load DSS</code>. (DynamicStackLoad)\nDynamicStackStore(imms=(dynamic_stack_slot: …\n<code>dynamic_stack_store x, DSS</code>. (DynamicStackStore) Type …\n<code>a = extract_vector x, y</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = extractlane x, Idx</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = f32const N</code>. (UnaryIeee32)\n<code>a = f64const N</code>. (UnaryIeee64)\n<code>a = fabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcmp Cond, x, y</code>. (FloatCompare) Type inferred from <code>x</code>.\n<code>a = fcopysign x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcvt_from_sint x</code>. (Unary)\n<code>a = fcvt_from_uint x</code>. (Unary)\n<code>a = fcvt_low_from_sint x</code>. (Unary)\n<code>a = fcvt_to_sint x</code>. (Unary)\n<code>a = fcvt_to_sint_sat x</code>. (Unary)\n<code>a = fcvt_to_uint x</code>. (Unary)\n<code>a = fcvt_to_uint_sat x</code>. (Unary)\n<code>a = fdemote x</code>. (Unary)\n<code>a = fdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>fence</code>. (NullAry)\n<code>f = ffcmp x, y</code>. (Binary) Type inferred from <code>x</code>.\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2)\n<code>a = floor x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fma x, y, z</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = fmax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmax_pseudo x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin_pseudo x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fneg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fpromote x</code>. (Unary)\nThe operand type can vary freely within the given set.\n<code>a = fsub x, y</code>. (Binary) Type inferred from <code>x</code>.\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0)\n<code>addr = func_addr FN</code>. (FuncAddr)\n<code>a = fvdemote x</code>. (Unary)\n<code>x = fvpromote_low a</code>. (Unary)\n<code>addr = get_frame_pointer</code>. (NullAry)\n<code>addr = get_pinned_reg</code>. (NullAry)\n<code>addr = get_return_address</code>. (NullAry)\n<code>addr = get_stack_pointer</code>. (NullAry)\n<code>a = global_value GV</code>. (UnaryGlobalValue)\nHeapAddr(imms=(heap: ir::Heap, offset: …\n<code>addr = heap_addr H, index, Offset, Size</code>. (HeapAddr)\nHeapLoad(imms=(heap_imm: ir::HeapImm), vals=1)\n<code>a = heap_load heap_imm, index</code>. (HeapLoad)\nHeapStore(imms=(heap_imm: ir::HeapImm), vals=2)\n<code>heap_store heap_imm, index, a</code>. (HeapStore) Type inferred …\n<code>a = iabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = iadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = iadd_carry x, y, c_in</code>. (Ternary) Type inferred …\n<code>a = iadd_cin x, y, c_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, c_out = iadd_cout x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = iadd_ifcarry x, y, c_in</code>. (Ternary) Type …\n<code>a = iadd_ifcin x, y, c_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, c_out = iadd_ifcout x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = iadd_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = iadd_pairwise x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = icmp Cond, x, y</code>. (IntCompare) Type inferred from <code>x</code>.\n<code>a = icmp_imm Cond, x, Y</code>. (IntCompareImm) Type inferred …\n<code>a = iconcat lo, hi</code>. (Binary) Type inferred from <code>lo</code>.\n<code>a = iconst N</code>. (UnaryImm)\n<code>f = ifcmp x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>f = ifcmp_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = imul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = imul_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nThis is an indirect call with the specified signature. See …\n<code>a = ineg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = insertlane x, y, Idx</code>. (TernaryImm8) Type inferred from …\nAn instruction format\nIntAddTrap(imms=(code: ir::TrapCode), vals=2)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2)\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\n<code>a = ireduce x</code>. (Unary)\n<code>a = irsub_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = is_invalid x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = is_null x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = ishl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ishl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>lo, hi = isplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>istore16 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore32 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore8 MemFlags, x, p, Offset</code>. (Store) Type inferred from …\n<code>a = isub x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = isub_bin x, y, b_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, b_out = isub_borrow x, y, b_in</code>. (Ternary) Type inferred …\n<code>a, b_out = isub_bout x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = isub_ifbin x, y, b_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, b_out = isub_ifborrow x, y, b_in</code>. (Ternary) Type …\n<code>a, b_out = isub_ifbout x, y</code>. (Binary) Type inferred from <code>x</code>.\nJump(imms=(destination: ir::Block), vals=0)\n<code>jump block, args</code>. (Jump)\nLoad(imms=(flags: ir::MemFlags, offset: …\n<code>a = load MemFlags, p, Offset</code>. (Load)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1)\nMultiAry(imms=(), vals=0)\n<code>a = nearest x</code>. (Unary) Type inferred from <code>x</code>.\n<code>nop</code>. (NullAry)\nThis is not a branch or jump instruction. This instruction …\nThis is not a call instruction.\n<code>a = null</code>. (NullAry)\nNullAry(imms=(), vals=0)\nAn instruction opcode.\nValue type constraints for a given opcode.\n<code>a = popcnt x</code>. (Unary) Type inferred from <code>x</code>.\nThe type constraint on a value argument once the …\n<code>resumable_trap code</code>. (Trap)\n<code>resumable_trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>return rvals</code>. (MultiAry)\n<code>a = rotl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = rotr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = scalar_to_vector s</code>. (Unary)\n<code>a = sdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sdiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = select c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = select_spectre_guard c, x, y</code>. (Ternary) Type inferred …\n<code>set_pinned_reg addr</code>. (Unary) Type inferred from <code>addr</code>.\n<code>a = sextend x</code>. (Unary)\nShuffle(imms=(imm: ir::Immediate), vals=2)\n<code>a = shuffle a, b, mask</code>. (Shuffle)\nThis is a branch or jump to a single destination block, …\n<code>a = sload16 MemFlags, p, Offset</code>. (Load)\n<code>a = sload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = sload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload8 MemFlags, p, Offset</code>. (Load)\n<code>a = sload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = smax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = snarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = splat x</code>. (Unary)\n<code>a = sqmul_round_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sqrt x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = srem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = srem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sshr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sshr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ssub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>addr = stack_addr SS, Offset</code>. (StackLoad)\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\n<code>a = stack_load SS, Offset</code>. (StackLoad)\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\n<code>stack_store x, SS, Offset</code>. (StackStore) Type inferred from …\nStore(imms=(flags: ir::MemFlags, offset: …\n<code>store MemFlags, x, p, Offset</code>. (Store) Type inferred from <code>x</code>.\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2)\n<code>a = swiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swizzle x, y</code>. (Binary)\n<code>a = symbol_value GV</code>. (UnaryGlobalValue)\nThis is a jump table branch which can have many …\nTableAddr(imms=(table: ir::Table, offset: …\n<code>addr = table_addr T, p, Offset</code>. (TableAddr)\nTernary(imms=(), vals=3)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2)\n<code>a = tls_value GV</code>. (UnaryGlobalValue)\nTrap(imms=(code: ir::TrapCode), vals=0)\n<code>trap code</code>. (Trap)\n<code>trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>trapz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>a = trunc x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uadd_overflow_trap x, y, code</code>. (IntAddTrap) Type …\n<code>a = uadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = uextend x</code>. (Unary)\n<code>a = uload16 MemFlags, p, Offset</code>. (Load)\n<code>a = uload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = uload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload8 MemFlags, p, Offset</code>. (Load)\n<code>a = uload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = umax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = unarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnary(imms=(), vals=1)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0)\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0)\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0)\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0)\n<code>a = urem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = urem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ushr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ushr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = usub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uunarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uwiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uwiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>s = vall_true a</code>. (Unary) Type inferred from <code>a</code>.\nSome instructions use an external list of argument values …\nMemory pool for holding value lists. See <code>ValueList</code>.\nA value type set describes the permitted set of types for …\n<code>s = vany_true a</code>. (Unary) Type inferred from <code>a</code>.\nA variable list of <code>Value</code> operands used for function call …\n<code>a = vconcat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = vconst N</code>. (UnaryConst)\n<code>x = vhigh_bits a</code>. (Unary)\n<code>a = vselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>lo, hi = vsplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = widening_pairwise_dot_product_s x, y</code>. (Binary)\nReturn information about the destination of a branch or …\nReturn information about a call instruction.\nGet the value arguments to this instruction.\nGet mutable references to the value arguments to this …\nIf this is an atomic read/modify/write instruction, return …\nGet the single destination of this branch instruction, if …\nGet a mutable reference to the single destination of this …\nCan this instruction read from memory?\nCan this instruction write to memory?\nCan this instruction cause a trap?\nIf this is a control-flow instruction depending on an …\nGet the constraint descriptor for this opcode. Panic if …\nDoes <code>typ</code> belong to this set?\nGet the typeset of allowed types for the controlling type …\nAllowed dynamic vectors minimum lane sizes\nCompare two <code>InstructionData</code> for equality.\nGet an example member of this type set.\nAllowed float widths\nGet the instruction format for this opcode.\nIf this is a control-flow instruction depending on a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert an <code>InstructionData</code> into an <code>InstructionImms</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Opcode name from a string.\nHash an <code>InstructionData</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this to a value list in <code>pool</code> with <code>fixed</code> prepended.\nAllowed int widths\nTrue for all branch or jump instructions.\nIs this a call instruction?\nCheck if the list is empty.\nIs this instruction polymorphic?\nReturns true if the instruction is a resumable trap.\nIs this a return instruction?\nTrue for instructions that terminate the block\nAllowed lane sizes\nIf this is a load/store instruction, returns its immediate …\nIf this is a load/store instruction, return its memory …\nCreate an empty argument list.\nGet the number of <em>fixed</em> result values produced by this …\nGet the number of <em>fixed</em> input values required by this …\nGet the opcode of this instruction.\nGet the opcode of this instruction.\nDoes this instruction have other side effects besides can_*…\nAdd an argument to the end.\nPut back a value list.\nAllowed ref widths\nIs it necessary to look at the designated value input …\nGet the value type of result number <code>n</code>, having resolved the …\nIf this instruction references a stack slot, return it\nTake out the value list with all the value arguments and …\nIf this is a trapping instruction, get its trap code. …\nIf this is a trapping instruction, get an exclusive …\nGet the controlling type variable operand.\nCan the controlling type variable for this opcode be …\nGet the value type of input value number <code>n</code>, having …\nConvert an <code>InstructionImms</code> into an <code>InstructionData</code> by …\nDoes this instruction write to CPU flags?\nContents of a jump table.\nAccess the whole table as a mutable slice.\nAccess the whole table as a slice.\nChecks if any of the entries branch to <code>block</code>.\nClears all entries in this jump table.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns an iterator over the table.\nReturns an iterator that allows modifying each value.\nGet the number of table entries.\nCreate a new empty jump table.\nAppend a table entry.\nCreate a new jump table with the provided blocks\nCreate a new empty jump table with the specified capacity.\nIterate over blocks in layout order. See …\nIterate over instructions in a block in layout order. See …\nThe <code>Layout</code> struct determines the layout of blocks and …\nInsert <code>block</code> as the last block in the layout.\nAppend <code>inst</code> to the end of <code>block</code>.\nReturns the capacity of the <code>BlockData</code> map.\nIterate over the instructions in <code>block</code> in layout order.\nIterate over a limited set of instruction which are likely …\nReturn an iterator over all blocks in layout order.\nFetch the first instruction in a block’s terminal branch …\nClear the layout.\nGet the function’s entry block. This is simply the first …\nFetch a block’s first instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert <code>block</code> in the layout before the existing block <code>before</code>…\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert <code>inst</code> before the instruction <code>before</code> in the same …\nGet the block containing <code>inst</code>, or <code>None</code> if <code>inst</code> is not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> currently part of the layout?\nIs the given block cold?\nGet the last block in the layout.\nFetch a block’s last instruction.\nCreate a new empty <code>Layout</code>.\nGet the block following <code>block</code> in the layout order.\nFetch the instruction following <code>inst</code>.\nGet the block containing the program point <code>pp</code>. Panic if <code>pp</code> …\nGet the block preceding <code>block</code> in the layout order.\nFetch the instruction preceding <code>inst</code>.\nRemove <code>block</code> from the layout.\nRemove <code>inst</code> from the layout.\nMark a block as “cold”.\nSplit the block containing <code>before</code> in two.\nContents of a dynamic stack slot.\nAll allocated dynamic stack slots.\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nThe size of an object on the stack, or the size of a stack …\nContents of a stack slot.\nThe kind of a stack slot.\nAll allocated stack slots.\nGet the alignment in bytes of this stack slot given the …\nGet the alignment in bytes of this stack slot given the …\nThe type of this slot.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of stack slot.\nThe kind of stack slot.\nCreate a stack slot with the specified byte size.\nCreate a stack slot with the specified byte size.\nSize of stack slot in bytes.\nA 32-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 64-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nCPU flags representing the result of a floating point …\nAn integer type with 128 bits.\nA SIMD vector with 2 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nAn integer type with 16 bits. WARNING: arithmetic on 16bit …\nA SIMD vector with 16 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 32 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 32 bits.\nA SIMD vector with 16 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 64 bits.\nA SIMD vector with 2 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 8 bits. WARNING: arithmetic on 8bit …\nA SIMD vector with 16 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 32 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 64 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 64 …\nA SIMD vector with 8 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nCPU flags representing the result of an integer …\nNot a valid type. Can’t be loaded or stored. Can’t be …\nAn opaque reference type with 32 bits.\nAn opaque reference type with 64 bits.\nThe type of an SSA value.\nGet a type with the same number of lanes as this type, but …\nGet a type with the same number of lanes as this type, but …\nGet a type with the same number of lanes as this type, but …\nGet the total number of bits used to represent this type.\nGet the (minimum, maximum) values represented by each lane …\nGet a SIMD vector type with <code>n</code> times more lanes than this …\nGet the number of bytes used to store this type in memory.\nGet a type with the same number of lanes as this type, but …\nConvert a dynamic vector type to a fixed one.\nReturns the argument unchanged.\nGet a SIMD vector with half the number of lanes.\nGet a type with the same number of lanes as this type, but …\nIndex of this type, for use with hash tables etc.\nGet an integer type with the requested number of bits.\nGet an integer type with the requested number of bytes.\nCalls <code>U::from(self)</code>.\nIs this a SIMD vector type with a runtime number of lanes?\nIs this a CPU flags type?\nIs this a scalar floating point type?\nIs this a scalar integer type?\nIs this the INVALID type?\nIs this a lane type?\nIs this a ref type?\nIs this a special type?\nIs this a SIMD vector type?\nGet the number of bits in a lane.\nGet the number of lanes in this SIMD vector type.\nThe type transformation that returns the lane type of a …\nGet the lane type of this SIMD vector type.\nGet log_2 of the number of bits in a lane.\nGet log_2 of the number of lanes in this SIMD vector type.\nGet log_2 of the number of lanes in this vector/dynamic …\nMerge lanes to half the number of lanes and double the …\nGet the minimum number of bits used to represent this type.\nGet the minimum of lanes in this SIMD vector type, this …\nSplit the lane width in half and double the number of …\nReturn the pointer type for the given target triple.\nConvert a fixed vector type to a dynamic one.\nTrue iff:\nMac aarch64 calling convention, which is a tweaked aarch64 …\nBuilder for a <code>TargetIsa</code>. Modify the ISA-specific settings …\nCalling convention identifiers.\nSmallest caller code size, not ABI-stable.\nBest performance, not ABI-stable.\nAfter determining that an instruction doesn’t have an …\nDescribes reason for target lookup failure\nSpecialized convention for the probestack function.\nSupport for this target was disabled in the current build.\nSystem V-style convention used on many platforms.\nThis struct provides information that a frontend may need …\nMethods that are specialized to a target ISA.\nSupport for this target has not yet been implemented.\nWasmtime equivalent of AppleAarch64, not ABI-stable.\nWasmtime equivalent of WindowsFastcall, not ABI-stable.\nWasmtime equivalent of SystemV, not ABI-stable.\nWindows “fastcall” convention, also used for x64 and …\nReturns the code (text) section alignment for this ISA.\nCompile the given function.\nCreates a new System V Common Information Entry for the …\nGet the default calling convention of this target.\nThe default calling convention of the target.\nGet the ISA-dependent maximum vector register size, in …\nCreates unwind information for the function.\nGet the endianness of this ISA.\nIs the calling convention extending the Apple aarch64 ABI?\nIs the calling convention extending the Wasmtime ABI?\nIs the calling convention extending the Windows Fastcall …\nCombine the ISA-specific settings with the provided …\nGet the ISA-independent flags that were used to make this …\nReturns the calling convention used for libcalls according …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the information needed by frontends producing …\nThe function alignment required by this ISA.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a flag indicating whether branch protection is enabled.\nGet the ISA-dependent flag values that were used to make …\nIterates the available settings in the builder.\nLook for an ISA for the given <code>triple</code>. Return a builder …\nLook for a supported ISA with the given <code>name</code>. Return a …\nGet the ISA-dependent MachineEnv for managing register …\nMap a regalloc::Reg to its corresponding DWARF register.\nGet the name of this ISA.\nGet the width of pointers on this ISA, in units of bits.\nGet the width of pointers on this target, in units of bits.\nGet the width of pointers on this ISA, in units of bytes.\nGet the width of pointers on this target, in units of …\nGet the pointer type of this ISA.\nGet the pointer type of this target.\nThe pointer width of the target.\nrisc-v 64-bit Instruction Set Architecture.\nReturns the minimum symbol alignment for this ISA.\nReturns an object that can be used to build the text …\nGet the target triple that was used to make this trait …\nGets the triple for the builder.\nReturn the default calling convention for the given target …\nIntCC condition for Unsigned Addition Overflow (Carry).\nRepresents information relating to function unwinding.\nX86_64-bit Instruction Set Architecture.\nAn riscv64 backend.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>isa::Builder</code>.\nCreate a new riscv64 backend with the given (shared) flags.\nDefines if the aarch64-specific pointer authentication …\nThe frame-pointer register for this architecture has just …\nThe frame-pointer register for this architecture has just …\nThe stack slot at the given offset from the clobber-area …\nThe stack pointer was adjusted to allocate the stack.\nSystem V ABI unwind information.\nRepresents unwind information for a single function.\nUnwind pseudoinstruction used in VCode backends: …\nWindows x64 ABI unwind information.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSystem V ABI unwind information.\nWindows x64 ABI unwind information.\nThe offset from the start of the clobber area to this …\nThe offset from the current SP and FP value downward to …\nThe offset from the current SP (after push) to the SP at …\nThe offset from the current SP and FP value upward to the …\nThe saved register.\nWhether return addresses (hold in LR) contain a …\nSize to allocate.\nEnumerate the errors possible in mapping Cranelift …\nRepresents unwind information for a single System V ABI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the encoding machinery for the various x64 …\nThe encoding formats in this module all require a way of …\nEncodes EVEX instructions. These instructions are those …\nAdd 1 byte to the code section.\nAdd 2 bytes to the code section.\nAdd 4 bytes to the code section.\nAdd 8 bytes to the code section.\nEncodes instructions in the standard x86 encoding mode. …\nEncodes VEX instructions. These instructions are those …\nDefines the EVEX context for the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits …\nConstructs an EVEX-encoded instruction using a builder …\nDefines the EVEX masking behavior; masking support is …\nThe EVEX format allows defining rounding control in the <code>L&#39;</code> …\nThe EVEX format allows choosing a vector length in the <code>L&#39;</code> …\nDescribe the register index to use. This wrapper is a …\nEncode the <code>aaa</code> bits for merging with the P2 byte.\nEncode the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits 6:4 of EVEX P2 byte) …\nEmit the EVEX-encoded instruction to the code sink:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction . Note that there are …\nSet the opcode map byte of the instruction: None | 0F | …\nSet the mask to use. See section 2.6 in the Intel Software …\nConstruct a default EVEX instruction.\nSet the instruction opcode byte.\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvvv</code> register; some instructions allow using this …\nSet the W bit, typically used to indicate an instruction …\nEncode the <code>z</code> bit for merging with the P2 byte.\nWe may need to include one or more legacy prefix bytes …\nNo prefix bytes.\nAllows using the same opcode byte in different “opcode …\nOperand Size Override – here, denoting “16-bit …\nOperand size override and Lock.\nOperand size override and same effect as F3.\nThe Lock prefix.\nREPNE, but no specific meaning here – is just an opcode …\nREP/REPE, but no specific meaning here – is just an …\nEncode the ModR/M byte.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a VEX-encoded instruction using a builder …\nThe VEX format allows choosing a vector length in the <code>L</code> …\nEmit the VEX-encoded instruction to the code sink:\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte. Overrides a previously set Self::imm_reg …\nSet the imm byte when used for a register. The reg bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction.\nSet the opcode map byte of the instruction: None | 0F | …\nConstruct a default VEX instruction.\nSet the instruction opcode byte.\nSome instructions use the ModRM.reg field as an opcode …\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvv</code> register; some instructions allow using this …\nSet the W bit, denoted by <code>.W1</code> or <code>.W0</code> in the instruction …\nA opaque reference to a code loop.\nLoop tree information for a single function.\nA level in a loop nest.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nA clamped loop level from a larger-width (usize) depth.\nClear all the data structures contained in the loop …\nDetects the loops in a function. Needs the control flow …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nOne loop level deeper.\nReturn the innermost loop for a given block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvalid loop level.\nDetermines if a loop is contained in another loop.\nDetermine if a Block belongs to a loop by running a finger …\nDetermine if a Block is a loop header. If so, return the …\nCheck if the loop analysis is in a valid state.\nGet the loop level.\nReturns the header block of a particular loop.\nReturns the loop-nest level of a given block.\nReturn the eventual parent of a loop in the loop tree.\nReturns all the loops contained in a function.\nAllocate a new blank loop analysis struct. Use <code>compute</code> to …\nGet the root level (no loop).\nPacked representation of <code>Option&lt;T&gt;</code>.\nTypes that have a reserved value which can’t be created …\nCreate a default packed option representing <code>None</code>.\nExpand the packed option into a normal <code>Option</code>.\nUnwrap a packed <code>Some</code> value or panic.\nConvert <code>t</code> into a packed <code>Some(x)</code>.\nConvert an option into its packed equivalent.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the packed option is a <code>None</code> value.\nChecks whether value is the reserved one.\nReturns <code>true</code> if the packed option is a <code>Some</code> value.\nMaps a <code>PackedOption&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function …\nCreate an instance of the reserved value.\nTakes the value out of the packed option, leaving a <code>None</code> …\nUnwrap a packed <code>Some</code> value or panic.\nPretty-print a Cranelift error.\nPretty-print a verifier error.\n<code>apple_aarch64</code>.\nNo setting by this name exists.\nType mismatch for setting (e.g., setting an enum setting …\nThis is not a valid value for this setting.\nThe setting is a boolean.\nCollect settings values based on a template.\n<code>coff</code>.\n<code>cold</code>.\nA string-based configurator for settings groups.\n<code>elf_gd</code>.\nThe setting is an enumeration.\nContains the error value\n<code>fast</code>.\nFlags group <code>shared</code>.\nWrapper containing flags and optionally a <code>TargetIsa</code> trait …\n<code>inline</code>.\n<code>isa_default</code>.\nValues for <code>shared.libcall_call_conv</code>.\n<code>macho</code>.\n<code>none</code>.\n<code>none</code>.\nThe setting is a number.\nContains the success value\nValues for <code>shared.opt_level</code>.\n<code>outline</code>.\nA reference to just the boolean predicates of a settings …\nThe setting is a preset.\n<code>probestack</code>.\nValues for <code>shared.probestack_strategy</code>.\nAn error produced when changing a setting.\nA result returned when changing a setting.\nRepresents an available builder setting.\nRepresents the kind of setting.\n<code>speed</code>.\n<code>speed_and_size</code>.\n<code>system_v</code>.\nValues for <code>shared.tls_model</code>.\nRepresents a setting value.\n<code>windows_fastcall</code>.\nReturns a slice with all possible OptLevel values.\nReturns a slice with all possible TlsModel values.\nReturns a slice with all possible LibcallCallConv values.\nReturns a slice with all possible ProbestackStrategy …\nGets the boolean value if the value is from a boolean …\nGets the enum value if the value is from an enum setting.\nGets the numerical value if the value is from a num …\nGenerate explicit checks around native division …\nCreate a <code>settings::Builder</code> for the shared settings group.\nThe description of the setting.\nImplementation details for generated code.\nEnable a boolean setting or apply a preset.\nDo redundant-load optimizations with alias analysis.\nEnable the use of atomic instructions\nEnable the use of floating-point instructions.\nEnable Spectre mitigation on heap bounds checks.\nEnable additional checks for debugging the incremental …\nEnable the use of jump tables in generated machine code.\nEnable various ABI extensions defined by LLVM’s behavior.\nEnable NaN canonicalization.\nEnable the use of the pinned register.\nEnable the use of stack probes for supported calling …\nEnable safepoint instruction insertions.\nEnable the use of SIMD instructions.\nEnable Spectre mitigation on table bounds checks.\nRun the Cranelift IR verifier at strategic times during …\nFlags are always present.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable Position-Independent Code generation.\nThe ISA may not be present.\nIterates the available settings in the builder.\nIterates the setting values.\nGets the kind of setting.\nThe kind of the setting.\nDefines the calling convention to use for LibCalls call …\nGenerate CFG metadata for machine code.\nThe name of the setting associated with this value.\nThe name of the setting.\nCreate a new builder with defaults and names from the …\nCreate a new view of a precomputed predicate vector.\nCreate flags shared settings group.\nOptimization level for generated code.\nGet a view of the boolean predicates.\nPreserve frame pointers\nEnable if the stack probe adjusts the stack pointer.\nThe log2 of the size of the stack guard region.\nControls what kinds of stack probes are emitted.\nEnable the symbolic checker for register allocation.\nEnable verbose debug logs for regalloc2.\nSet the string value of any setting by name.\nExtract contents of builder once everything is configured.\nCheck a numbered predicate.\nDefines the model used to perform TLS accesses.\nGenerate unwind information.\nUse colocated libcalls.\nEnable egraph-based optimization.\nUse the pinned register as the heap base.\nBuilds a string from the current value\nThe supported values of the setting (for enum values).\nA boolean setting only uses one bit, numbered from LSB.\nA setting descriptor holds the information needed to …\nThe different kind of settings along with descriptor bits …\nAn Enum setting uses a range of enumerators.\nA numerical setting uses the whole byte.\nA preset is not an individual setting, it is a collection …\nAn instruction group template.\nDefault values.\nThe description of the setting.\nList of setting descriptors.\nAdditional details, depending on the kind of setting.\nUnion of all enumerators.\nGet enumerators corresponding to a <code>Details::Enum</code>.\nFormat a setting value as a TOML string. This is mostly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash table of settings.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a detail is a Detail::Preset. Useful because the …\nName of the instruction group.\nLower snake-case name of setting as defined in meta.\nOffset of byte containing this setting.\nPairs of (mask, value) for presets.\n0-7.\nFirst enumerator in the ENUMERATORS table.\nNumerical value of last enumerator, allowing for 1-256 …\nAccumulated timing for all passes.\nA timing token is responsible for timing the currently …\nAdd <code>timings</code> to the accumulated timings for the current …\nCanonicalization of NaNs\nCompilation passes\nDead code elimination\nDominator tree\nControl flow graph\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobal value numbering\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayout full renumbering\nLoop invariant code motion\nLoop analysis\nParsing textual Cranelift IR\nPre-legalization rewriting\nProcessing test file\nRegister allocation\nRegister allocation symbolic verification\nRemove constant phi-nodes\nStore in incremental cache\nTake the current accumulated pass timings and reset the …\nReturns the total amount of time taken by all the passes …\nTry loading from incremental cache\nRemove unreachable blocks\nVCode emission\nVCode emission finalization\nVCode lowering\nVerify Cranelift IR\nVerify CPU flags\nTranslate WASM function\nTranslate WASM module\nContains the error value\nContains the error value\nContains the success value\nContains the success value\nA verifier error.\nList of verifier errors.\nResult of a verification operation.\nResult of a step in the verification process.\nReturn a <code>VerifierStepResult</code> that is fatal if at least one …\nOptionally provide some context for the given location; …\nReport a fatal error and return <code>Err</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn whether one or more errors were reported.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn whether no errors were reported.\nThe entity causing the verifier error.\nThe error message.\nReturn a new <code>VerifierErrors</code> struct.\nReport a non-fatal error and return <code>Ok</code>.\nReport an error, adding it to the list of errors.\nVerify <code>func</code> after checking the integrity of associated …\nVerify <code>func</code>.\nA <code>FuncWriter</code> used to decorate functions during printing.\nA <code>PlainWriter</code> that doesn’t decorate the function.\nWrites <code>func</code> to <code>w</code> as text. write_function_plain is passed …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDefault impl of <code>write_entity_definition</code>\nDefault impl of <code>write_preamble</code>\nWrite out the basic block header, outdented:\nWrite the basic block header for the current function.\nWrite an entity definition defined in the preamble to <code>w</code>.\nWrite <code>func</code> to <code>w</code> as equivalent text. Use <code>isa</code> to emit …\nWrite the given <code>inst</code> to <code>w</code>.\nWrite the operands of <code>inst</code> to <code>w</code> with a prepended space.\nWrite the preamble to <code>w</code>. By default, this uses …")