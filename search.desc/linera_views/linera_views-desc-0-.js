searchState.loadedDescShard("linera_views", 0, "This module is used in the Linera protocol to map complex …\nThe definition of the batches for writing in the database. …\nThe <code>CollectionView</code> implements a map structure whose keys …\nThe definitions used for the <code>KeyValueStore</code> and <code>Context</code>. …\nA storage backend for views based on DynamoDB\nWrapping a view to compute a hash.\nIncrements the metrics counter with the given name, with …\nThe code to turn a <code>DirectKeyValueStore</code> into a <code>KeyValueStore</code>…\nThe implementation of a key-value store view.\nThe <code>LogView</code> implements a log list that can be pushed.\nThe LRU (least recently used) caching.\nThe <code>MapView</code> implements a map with ordered keys. The <code>MapView</code>…\nHelper definitions for in-memory storage.\nThe code for encapsulating one key_value store into …\nThis module defines util functions for interacting with …\nThe <code>QueueView</code> implements a queue that can push on the back …\nThe <code>ReentrantCollectionView</code> implements a map structure …\nThe <code>RegisterView</code> implements a register for a single value.\nA storage backend for views based on RocksDB\nA storage backend for views based on ScyllaDB This …\nThe <code>SetView</code> implements a set with ordered entries.\nHelper types for tests.\nThe code for handling big values by splitting them into …\nThe definition of the <code>View</code> and related traits.\nA batch of write operations.\nAn iterator-like object that can write values one by one …\nDelete the given key.\nDelete all the keys matching the given prefix.\nA trait to expand delete_prefix operations. Certain …\nThe error type that can happen when expanding the …\nThe error type that can happen when expanding the …\nThe iterator type used to process values from the batch.\nA trait to expand delete_prefix operations. Certain …\nSet or replace the value of a given key.\nA batch of deletions and insertions that operate on …\nThe iterator that corresponds to a SimpleUnorderedBatch\nA notion of batch useful for certain computations (notably …\nAn unordered batch of deletions and insertions, together …\nThe iterator that corresponds to a SimpleUnorderedBatch\nA write operation as requested by a view when it needs to …\nAdds the deletion of key to the batch.\nAdds the insertion of a key-value pair to the batch.\nBuilds a batch from a builder function.\nChecks the size of the values of the batch.\nInserts the deletion of a <code>key</code> into the batch.\nInserts the deletion of a <code>key_prefix</code> into the batch.\nThe deletions.\nModifies an <code>UnorderedBatch</code> so that the key-prefix …\nReturns the list of keys to be appended to the list.\nReturns the list of keys to be appended to the list.\nFrom an <code>UnorderedBatch</code>, creates a <code>SimpleUnorderedBatch</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a simplified batch from a standard one.\nThe insertions.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an owning iterator over the values in the batch.\nReturns true if there are no more values to write.\nReturns true if the batch is empty.\nThe key-prefix deletions.\nReturns the total number of entries in the batch.\nCreates an empty batch.\nComputes the batch size that we would obtain if we wrote …\nReturns the total number of bytes in the batch.\nReturns the number of operations in this <code>Batch</code>.\nThe write operations.\nReturns the overhead size of the batch.\nAdds the insertion of a key-value pair into the batch with …\nAdds the insertion of a <code>(key, value)</code> pair into the batch …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe batch of deletions and insertions.\nSimplifies the batch by removing operations that are …\nThe total size of the batch\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the next value (if any) to the batch and updates …\nThe key that will be deleted.\nThe key to be inserted or replaced.\nThe prefix of the keys to be deleted.\nThe value to be inserted on the key.\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA MapView that serializes the indices.\nType wrapping <code>ByteCollectionView</code> while memoizing the hash.\nType wrapping <code>CollectionView</code> while memoizing the hash.\nType wrapping <code>CustomCollectionView</code> while memoizing the …\nA read-only accessor for a particular subview in a …\nTests if the collection contains a specified key and …\nGets the extra data.\nGets the extra data.\nGets the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index (aka key). Keys are …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the collection in the order …\nReturns the list of indices in the collection in the order …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys in the collection. The order is …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nMarks the entry as removed. If absent then nothing is done.\nRemoves an entry from the CollectionView. If absent …\nRemoves an entry from the CollectionView. If absent …\nResets an entry to the default value.\nResets an entry to the default value.\nMarks the entry so that it is removed in the next flush.\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nLow-level trait for the administration of stores and their …\nThe common initialization parameters for the <code>KeyValueStore</code>\nThe configuration needed to interact with a new store.\nThe configuration needed to interact with a new store.\nThe context in which a view is operated. Typically, this …\nImplementation of the <code>Context</code> trait on top of a DB client …\nSometimes we need a serialization that is different from …\nThe error type.\nThe error type.\nThe error type returned by the store’s methods.\nThe error type returned by the store’s methods.\nThe error type in use by internal operations. In practice, …\nUser-provided data to be carried along.\nThe iterator returning keys by reference.\nThe iterator that returns key-value pairs by reference.\nThe iterator that returns key-value pairs by value.\nHow to iterate over the keys returned by a search query.\nHow to iterate over the key-value pairs returned by a …\nLow-level, asynchronous write and read key-value …\nReturns type for key-value search operations.\nReturns type for key-value search operations.\nReturns type for key-value search operations.\nReturns type for key search operations.\nReturns type for key search operations.\nReturns type for key search operations.\nLow-level trait for the administration of stores and their …\nLow-level, asynchronous write and read key-value …\nLow-level, asynchronous read key-value operations. Useful …\nLow-level, asynchronous write key-value operations. Useful …\nThe maximal size of keys that can be stored.\nThe maximal size of keys that can be stored.\nThe maximal size of keys that can be stored.\nThe maximal size of values that can be stored.\nThe maximal size of values that can be stored.\nThe maximal size of values that can be stored.\nThe minimum value for the view tags. Values in …\nLow-level, asynchronous read key-value operations. Useful …\nLow-level, asynchronous write key-value operations. Useful …\nConcatenates the base_key and index.\nGetter for the address of the current entry (aka the …\nThe base key for the current view.\nConcatenates the base_key and tag.\nConcatenates the base_key, tag and index.\nThe cache size being used.\nClears any journal entry that may remain. The journal is …\nClears any journal entry that may remain. The journal is …\nObtains a similar <code>Context</code> implementation with a different …\nConnects to an existing namespace using the given …\nConnects to an existing namespace using the given …\nTests whether a key exists in the database\nTests whether a key exists in the database\nTests whether a key exists in the database\nTests whether a list of keys exist in the database\nTests whether a list of keys exist in the database\nTests whether a set of keys exist in the database\nCreates a namespace. Returns an error if the namespace …\nCreates a namespace. Returns an error if the namespace …\nCreates a context from store that also clears the journal …\nDeletes the given namespace.\nDeletes the given namespace.\nDeletes all the existing namespaces.\nDeletes all the existing namespaces.\nObtains the <code>Vec&lt;u8&gt;</code> key from the key by serialization and …\nObtains the short <code>Vec&lt;u8&gt;</code> key from the key by …\nObtains the <code>Vec&lt;u8&gt;</code> key from the key by serialization and …\nDeserialize <code>bytes</code> into type <code>Item</code>.\nTests if a given namespace exists.\nTests if a given namespace exists.\nGetter for the user-provided data.\nUser-defined data attached to the view.\nFinds the <code>(key,value)</code> pairs matching the prefix. The …\nFinds the <code>(key,value)</code> pairs matching the prefix. The …\nFinds the <code>(key,value)</code> pairs matching the <code>key_prefix</code>. The …\nFinds the <code>key</code> matching the prefix. The prefix is not …\nFinds the <code>key</code> matching the prefix. The prefix is not …\nFinds the keys matching the <code>key_prefix</code>. The <code>key_prefix</code> is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes an Optional vector of u8\nDeserialize the vector\nComputes an interval so that a vector has <code>key_prefix</code> as a …\nThis computes the offset of the BCS serialization of a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterates keys and values by value.\nIterates keys by reference.\nIterates keys and values by reference.\nObtains the list of existing namespaces.\nObtains the list of existing namespaces.\nThe number of concurrent to a database\nRetrieve the number of stream queries.\nRetrieve the number of stream queries.\nRetrieves the number of stream queries.\nThe number of streams used for the async streams.\nInitializes a storage if missing and provides it.\nInitializes a storage if missing and provides it.\nCreates a <code>RocksDbContext</code>.\nCreates a …\nCreates a <code>KeyValueStoreMemoryContext</code>.\nCreates a <code>ScyllaDbContext</code>.\nCreates a <code>MemoryContext</code>.\nCreates a new <code>DynamoDbContext</code> instance from the given AWS …\nCreates a <code>MemoryContext</code> for testing.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads multiple <code>keys</code> and deserializes the results if …\nReads multiple <code>keys</code> and deserializes the results if …\nReads multiple <code>keys</code> and deserializes the results if …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nReads a single <code>key</code> and deserializes the result if present.\nReads a single <code>key</code> and deserializes the result if present.\nRetrieves a generic <code>Item</code> from the database using the …\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nCreates a new storage. Overwrites it if this namespace …\nCreates a new storage. Overwrites it if this namespace …\nThe DB client that is shared between views.\nSerializes the value\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>batch</code> in the database with <code>base_key</code> the base …\nWrites the <code>batch</code> in the database with <code>base_key</code> the base …\nApplies the operations from the <code>batch</code>, persisting the …\nAlready existing database\nAn error occurred while writing a batch of items.\nA BCS error occurred.\nAn error occurred while building an object\nThe configuration to connect to DynamoDB.\nAn error occurred while creating the table.\nThe database is not coherent\nThe recovery failed.\nAn error occurred while deleting a table\nAn implementation of <code>Context</code> based on <code>DynamoDbStore</code>.\nA set of <code>(key, value)</code> returned by a search query on …\nA set of keys returned by a search query on DynamoDB.\nA shared DB client for DynamoDb implementing LruCaching\nThe initial configuration of the system\nErrors that occur when using <code>DynamoDbContext</code>.\nA DynamoDB client.\nAn error occurred while getting the item.\nallowed characters are lowercase letters, numbers, periods …\nError when validating a table name.\nA wrong table name error occurred\nThe journal is not coherent\nThe key prefix must have at most 1024 bytes\nThe key must have at most 1024 bytes\nAn error occurred while listing tables\nA type to help tests that need a LocalStack instance.\nMissing database\nThe stored key is missing.\nThe value attribute is missing.\nAn error occurred while doing a Query.\nThe table name should be at most 63 characters.\nThe table name should be at least 3 characters.\nThe transact maximum size is MAX_TRANSACT_WRITE_ITEM_SIZE.\nAn error occurred while writing a transaction of items.\nThe length of the value should be at most 400KB.\nThe type of the keys was not correct (It should have been …\nThe value was stored as the wrong type (it should be a …\nKeys have to be of non-zero length.\nKey prefixes have to be of non-zero length.\nThe base key for the current view.\nThe common configuration of the key value store\nThe AWS configuration\nCreates the common initialization for RocksDB\nCreates a configuration for tests\nCreates a basic client that can be used for tests.\nCreates a new <code>aws_sdk_dynamodb::Config</code> for tests, using a …\nUser-defined data attached to the view.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the AWS configuration from the environment\nGetting a configuration for the system\nGets the localstack config\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an instance of <code>LocalStackTestContext</code>, loading the …\nCreates a new <code>DynamoDbContext</code> instance from the given AWS …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe DB client that is shared between views.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nCreates a <code>DynamoDbStoreError::WrongKeyType</code> instance based …\nCreates a <code>DynamoDbStoreError::WrongValueType</code> instance …\nA hash for ContainerView and storing of the hash for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe batch type.\nLow-level, asynchronous direct read/write key-value …\nLow-level, asynchronous direct write key-value operations …\nThe error type.\nThe journal block could not be retrieved, it could be …\nData type indicating that the database is not consistent\nA journaling <code>KeyValueStore</code> built from an inner …\nThe maximal number of items in a batch.\nThe maximal number of bytes of a batch.\nThe maximal size of values that can be stored.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe read stuff does not change\nCreates a new journaling store.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe inner store.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the batch to the database.\nA context that stores all values in memory.\nA view that represents the functions of KeyValueStore …\nA pair containing the key and value size.\nA virtual DB client using a <code>KeyValueStoreView</code> as a backend …\nAdd a size to the existing SizeData\nThe base key for the current view.\nTests whether the store contains a specific index.\nTests whether the view contains a range of indices\nReturns the number of entries.\nUser-defined data attached to the view.\nIterates over all the key-value pairs, for keys matching …\nIterates over all the keys matching the given prefix. The …\nApplies the function f over all indices.\nApplies the function f over all index/value pairs.\nApplies the function f over all index/value pairs. If the …\nApplies the function f over all indices. If the function f …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObtains the value at the given index, if any.\nReturns the list of indices and values in lexicographic …\nReturns the list of indices in lexicographic order.\nSets or inserts a value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe size of the key\nObtains the values of a range of indices\nCreates a <code>KeyValueStoreMemoryContext</code>.\nCreates a <code>ViewContainer</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value. If absent then the action has no effect.\nDeletes a key_prefix.\nThe DB client that is shared between views.\nSubtract a size to the existing SizeData\nSums both terms\nSums both terms\nGetting the total sizes that will be used for keys and …\nThe size of the value\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nApplies the given batch of <code>crate::common::WriteOperation</code>.\nType wrapping <code>LogView</code> while memoizing the hash.\nA view that supports logging values of type <code>T</code>.\nReads the size of the log.\nObtains the extra data.\nReturns the argument unchanged.\nReads the logged value with the given index (including …\nCalls <code>U::from(self)</code>.\nReads several logged keys (including staged ones)\nPushes a value to the end of the log.\nReads the logged values in the given range (including …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA context that stores all values in memory.\nWe take a store, a maximum size and build a LRU-based …\nThe standard cache size used for tests.\nThe base key for the current view.\nUser-defined data attached to the view.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a …\nCreates a new key-value store that provides LRU caching at …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe DB client that is shared between views.\nThe inner store that is called by the LRU cache one\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that supports inserting and removing values indexed …\nA Custom MapView that uses the custom serialization\nType wrapping <code>ByteMapView</code> while memoizing the hash.\nType wrapping <code>CustomMapView</code> while memoizing the hash.\nType wrapping <code>MapView</code> while memoizing the hash.\nA <code>View</code> that has a type for keys. The ordering of the …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns the number of keys of the map\nObtains the extra data.\nObtains the extra data.\nObtains the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function on each index/value pair. Indices and …\nApplies a function f on each index/value pair. Indices and …\nApplies a function f on each index/value pair. Indices and …\nApplies a function f on the index/value pairs. Indices and …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies the function f on each index (aka key) having the …\nApplies a function f on each key/value pair matching a …\nApplies a function f on each index/value pair matching a …\nApplies the function f on each index (aka key) which has …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReads the value at the given position, if any.\nReads the value at the given position, if any.\nReads the value at the given position, if any.\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position.\nObtains a mutable reference to a value at a given position.\nObtains a mutable reference to a value at a given position.\nReturns the list of indices in the map. The order is …\nReturns the list of indices in the map. The order is …\nInserts or resets the value of a key of the map.\nInserts or resets a value at an index.\nInsert or resets a value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys and values of the map in …\nReturns the list of keys and values of the map matching a …\nReturns the list of keys of the map in lexicographic order.\nReturns the list of keys of the map having a specified …\nReads the values at the given positions, if any.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value. If absent then nothing is done.\nRemoves a value. If absent then the operation does nothing.\nRemoves a value. If absent then this does not do anything.\nRemoves a value. If absent then nothing is done.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nSerialization error with BCS.\nThe database is not consistent\nAn implementation of <code>crate::common::Context</code> that stores …\nA virtual DB client where data are persisted in memory.\nThe initial configuration of the system\nThe error type for <code>MemoryContext</code>.\nThe namespace does not exist\nThe number of streams for the test\nThe value is too large for the MemoryStore\nThe base key for the current view.\nThe common configuration of the key value store\nCreates a default memory test config\nProvides a <code>MemoryContext&lt;()&gt;</code> that can be used for tests. …\nCreates a test memory store for working.\nUser-defined data attached to the view.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>MemoryContext</code>.\nCreates a <code>MemoryStoreConfig</code>. <code>max_concurrent_queries</code> and …\nCreates a <code>MemoryStore</code> from a number of queries and a …\nCreates a <code>MemoryContext</code> for testing.\nCreates a <code>MemoryStore</code> from a number of queries and a …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe DB client that is shared between views.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe implementation of the <code>KeyValueStoreMetrics</code> for the …\nA metered wrapper that keeps track of every operation\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreation of a named Metered counter.\nCreates a new Metered store\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe underlying store of the metered store\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA guard for an active latency measurement.\nAn extension trait for metrics that can be used to measure …\nFinishes the measurement, updates the <code>Metric</code> and the …\nUpdates the metric with measured latency in <code>milliseconds</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStarts measuring the latency, finishing when the returned …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrapper arount prometheus register_histogram_vec! macro …\nWrapper arount prometheus register_int_counter_vec! macro …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>QueueView</code> while memoizing the hash.\nA view that supports a FIFO queue for values of type <code>T</code>.\nReads the back value, if any.\nReads the size of the queue.\nDeletes the front value, if any.\nReads all the elements\nObtains the extra data.\nReturns the argument unchanged.\nReads the front value, if any.\nCalls <code>U::from(self)</code>.\nGets a mutable iterator on the entries of the queue\nPushes a value to the end of the queue.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads the <code>count</code> last values in the queue (including staged …\nReads the <code>count</code> next values in the queue (including staged …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>ReentrantByteCollectionView</code> while memoizing …\nType wrapping <code>ReentrantCollectionView</code> while memoizing the …\nType wrapping <code>ReentrantCustomCollectionView</code> while …\nA read-only accessor for a particular subview in a …\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA read-write accessor for a particular subview in a …\nReturns <code>true</code> if the collection contains a value for the …\nReturns <code>true</code> if the collection contains a value for the …\nReturns <code>true</code> if the collection contains a value for the …\nGets the extra data.\nGets the extra data.\nGets the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index (aka key). Keys are …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the collection in an order …\nReturns the list of indices in the collection. The order …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of indices in the collection in …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves an entry. If absent then nothing happens.\nMarks the entry so that it is removed in the next flush.\nRemoves an entry. If absent then nothing happens.\nLoads all the entries for reading at once.\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads all the entries for writing at once.\nLoads all entries for writing at once. The entries in …\nLoads all entries for writing at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads multiple entries for writing at once. The entries in …\nLoad multiple entries for writing at once. The entries in …\nLoad multiple entries for writing at once. The entries in …\nLoads a subview at the given index in the collection and …\nLoads a subview at the given index in the collection and …\nLoads a subview at the given index in the collection and …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nMarks the entry so that it is removed in the next flush.\nMarks the entry so that it is removed in the next flush.\nMarks the entry so that it is removed in the next flush.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>RegisterView</code> while memoizing the hash.\nA view that supports modifying a single value of type <code>T</code>.\nObtains the extra data.\nReturns the argument unchanged.\nAccess the current value in the register.\nObtains a mutable reference to the value in the register.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nSets the value in the register.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nAlready existing database\nBCS serialization error.\nThe RocksDB client that we use.\nThe database is not coherent\nFilesystem error\nError converting <code>OsString</code> to <code>String</code>\nInvalid table name\nThe key must have at most 8M\nMissing database\nThe database contains a file which is not a directory\nRocksDB error.\nAn implementation of <code>crate::common::Context</code> based on …\nA shared DB client for RocksDB implementing LruCaching\nThe initial configuration of the system\nThe error type for <code>RocksDbContext</code>\nThe internal client\nTokio join error in RocksDb.\nThe base key for the current view.\nThe common configuration of the key value store\nCreates the common initialization for RocksDB\nReturns the test config and a guard for the temporary …\nReturns the test path for RocksDB without common config.\nCreates a RocksDB database client to be used for tests. …\nUser-defined data attached to the view.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>RocksDbContext</code>.\nThe AWS configuration\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe DB client that is shared between views.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nAlready existing database\nBCS serialization error.\nThe database is not coherent\nTable name contains forbidden characters\nThe journal is not coherent\nThe key must have at most 1M bytes\nMissing database\nAn implementation of <code>crate::common::Context</code> based on …\nA query error in ScyllaDB\nA query error in ScyllaDB\nA row error in ScyllaDB\nA shared DB store for ScyllaDB implementing LruCaching\nThe type for building a new ScyllaDB Key Value Store\nThe error type for <code>ScyllaDbStoreInternal</code>\nThe client itself and the keeping of the count of active …\nThe base key for the current view.\nThe common configuration of the key value store\nCreates the common initialization for RocksDB.\nCreates a ScyllaDB test store config.\nCreates a ScyllaDB test store.\nCreates the URI used for the tests.\nUser-defined data attached to the view.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieves the table_name from the store\nGets the table name of the ScyllaDB store.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>ScyllaDbContext</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe DB client that is shared between views.\nThe url to which the requests have to be sent\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that supports inserting and removing values indexed …\nA [‘View’] implementing the set functionality with the …\nType wrapping <code>ByteSetView</code> while memoizing the hash.\nType wrapping <code>CustomSetView</code> while memoizing the hash.\nType wrapping <code>SetView</code> while memoizing the hash.\nA [‘View’] implementing the set functionality with the …\nReturns true if the given index exists in the set.\nReturns true if the given index exists in the set.\nReturns true if the given index exists in the set.\nGets the extra data.\nObtains the extra data.\nObtains the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each serialized index (aka key). …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the set. The order is …\nReturns the list of indices in the set. The order is …\nInsert a value. If already present then it has no effect.\nInserts a value. If already present then no effect.\nInserts a value. If present then it has no effect.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys in the set. The order is …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value from the set. If absent then no effect.\nRemoves a value. If absent then nothing is done.\nRemoves a value. If absent then nothing is done.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA deterministic RNG.\nA RNG that is non-deterministic if the platform supports …\nExercises the functionalities of the <code>AdminKeyValueStore</code>. …\nReturns the argument unchanged.\nGet a random alphanumeric string that can be used for all …\nReturns a unique namespace for testing.\nTakes a random number generator, a key_prefix and extends …\nReturns a random key_prefix used for tests\nA bunch of puts and some deletes.\nTakes a random number generator rng, a number n and …\nTakes a random number generator, a key_prefix and generates\nBuilds a random k element subset of n\nWe build a number of scenarios for testing the reads.\nAppends a small value to a key making collisions likely.\nCalls <code>U::from(self)</code>.\nReturns a deterministic RNG for testing.\nReturns a non-deterministic RNG where supported.\nShuffles the values entries randomly\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nAccess the internal RNG.\nDynamoDb has limits at 1M (for pagination), 4M (for write) …\nThis test starts with a collection of key/values being …\nWrites and then reads data under a prefix, and verifies …\nRun many operations on batches always starting from a …\nRun some deterministic and random batches operation and …\nA random reordering of the puts and deletes. For something …\nSome <code>View</code>s that are easy to use with test cases.\nThat test is especially challenging for ScyllaDB. In its …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nRepresentation of the view’s state.\nWrapper to test with a <code>CollectionView</code>.\nWrapper to test with a <code>LogView</code>.\nWrapper to test with a <code>MapView</code>.\nWrapper to test with a <code>RegisterView</code>.\nA <code>View</code> to be used in test cases.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads the view’s current state.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nStages some changes to the view that won’t be persisted …\nStages some changes to the view that will be persisted …\nPerforms some initial changes to the view, staging them, …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nData type indicating that the database is not consistent\nA memory store for which the values are limited to 100 …\nvalue segment is missing from the database\nno count of size u32 is available in the value\nThe key is of length less than 4, so we cannot extract the …\nA key-value store with no size limit for values.\nProvides a <code>LimitedTestMemoryStore&lt;()&gt;</code> that can be used for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new store that deals with big values from one …\nCreates a <code>LimitedTestMemoryStore</code>\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe underlying store of the transformed store.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nArithmetic error\nWe failed to acquire an entry in a CollectionView or a …\nA <code>ClonableView</code> supports being shared (unsafely) by cloning …\nA <code>RootView</code> that also supports crypto hash\nA <code>View</code> that also supports crypto hash\nA view that supports hashing its values.\nThe requirement for the hasher type in <code>HashableView</code>.\nHow to compute hashes.\nThe database is corrupt: Entries don’t have the expected …\nInput output error.\nThe key must not be too long\nThe database is corrupt: Some entries are missing\nThe number of keys used for the initialization\nFIXME(#148): This belongs to a future …\nThe output type.\nThe values are incoherent.\nA <code>View</code> whose staged modifications can be saved in storage.\nAn error occurred during BCS serialization.\nErrors within the context can occur and are presented as …\nTokio errors can happen while joining.\nThe value is too large for the client\nAn error happened while trying to lock.\nA view gives exclusive access to read and write the data …\nMain error type for the crate.\nErrors can happen within the Wasm guest and have to be …\nClears the view. That can be seen as resetting to default. …\nCreates a clone of this view, sharing the underlying …\nObtains a mutable reference to the internal context.\nComputing the hash and attributing the type to it.\nComputing the hash and attributing the type to it.\nFinishes the hashing process and returns its output.\nPersists changes to storage. This leaves the view still …\nReturns the argument unchanged.\nReturns <code>true</code> if flushing this view would result in changes …\nComputes the hash of the values.\nComputes the hash of the values.\nCalls <code>U::from(self)</code>.\nLoads a view\nBuilds a trivial view that is already deleted\nCreates a <code>NotFound</code> error with the given message and key.\nLoads a view from the values\nCreates the keys needed for loading the view\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nDiscards all pending changes. After that <code>flush</code> should have …\nSaves the root view to the database context\nSerializes a value with BCS and includes it in the hash.\nIncludes bytes in the hash.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nbackend can be e.g. RocksDB / DynamoDB / Memory / etc.\nerror is the specific problem that occurred within that …")